import os
import multiprocessing as mp
from tqdm import tqdm
import math
from gmpy2 import mpz, is_prime, sqrt, gcd

mp.dps = 300

def calcular_diferencas_periodicas(raizes, periodo, numero_ciclo):
    """
    Calcula a matriz de diferenças periódicas (Xi) para as raízes dadas.

    Args:
        raizes (list): Lista de raízes.
        periodo (int): Período do ciclo.
        numero_ciclo (int): Número do ciclo.

    Returns:
        list: Matriz de diferenças periódicas (Xi).
    """
    n = len(raizes)
    Xi = [[None for _ in range(n)] for _ in range(n)]

    for i in range(n):
        raiz_i = mpz(raizes[i])
        for j in range(n):
            quociente_j = mpz(raizes[j]) + mpz(periodo) * (mpz(numero_ciclo) - 1)
            quociente_j_chave = None

            for j_chave in range(n):
                if j_chave != j:
                    if ((quociente_j * mpz(raizes[j_chave])) - raiz_i) % mpz(periodo) == 0:
                        quociente_j_chave = mpz(raizes[j_chave])
                        break

            if quociente_j_chave is not None:
                Xi[i][j] = mpz(1) + ((quociente_j * quociente_j_chave - raiz_i) // mpz(periodo))

    return Xi

def construir_conjunto_multiplos(Xi, raizes, periodo, numero_ciclo, limite_inferior, limite_superior):
    """
    Constrói o conjunto de múltiplos (L_b) para as raízes dadas.

    Args:
        Xi (list): Matriz de diferenças periódicas.
        raizes (list): Lista de raízes.
        periodo (int): Período do ciclo.
        numero_ciclo (int): Número do ciclo.
        limite_inferior (int): Limite inferior do intervalo de busca.
        limite_superior (int): Limite superior do intervalo de busca.

    Returns:
        dict: Conjunto de múltiplos (L_b).
    """
    L_b = {mpz(r): set() for r in raizes}

    n = len(raizes)
    periodo = mpz(periodo)
    limite_inferior = mpz(limite_inferior)
    limite_superior = mpz(limite_superior)

    for i in range(n):
        raiz_i = mpz(raizes[i])
        for j in range(n):
            multiplo_ij = Xi[i][j]
            if multiplo_ij is not None:
                for theta in range(1, numero_ciclo + 1):
                    composto = (multiplo_ij + periodo * (theta - 1)) * periodo + raiz_i
                    if limite_inferior <= composto <= limite_superior:
                        L_b[raiz_i].add(multiplo_ij + periodo * (theta - 1))

    return L_b

def encontrar_primos_em_lote(inicio, fim):
    """
    Encontra todos os números primos dentro de um determinado intervalo.

    Args:
        inicio (int): Início do intervalo.
        fim (int): Fim do intervalo.

    Returns:
        list: Lista de números primos no intervalo.
    """
    inicio, fim = mpz(inicio), mpz(fim)
    return [num for num in range(inicio, fim + 1) if is_prime(num)]

def encontrar_primos_em_paralelo(inicio, fim, tamanho_lote, arquivo_saida, num_processos):
    """
    Encontra números primos dentro de um intervalo usando processamento paralelo e os salva em um arquivo.

    Args:
        inicio (int): Início do intervalo.
        fim (int): Fim do intervalo.
        tamanho_lote (int): Tamanho de cada lote de processamento.
        arquivo_saida (str): Nome do arquivo para salvar os primos.
        num_processos (int): Número de processos a serem usados.
    """
    pool = mp.Pool(processes=num_processos)
    inicio, fim, tamanho_lote = mpz(inicio), mpz(fim), mpz(tamanho_lote)

    with open(arquivo_saida, 'w') as f:
        for inicio_lote in tqdm(range(inicio, fim + 1, tamanho_lote), desc="Processando lotes"):
            fim_lote = min(inicio_lote + tamanho_lote - 1, fim)

            tamanho_sublote = (fim_lote - inicio_lote + 1) // num_processos
            sublotes = [(inicio_lote + i * tamanho_sublote,
                         min(inicio_lote + (i + 1) * tamanho_sublote - 1, fim_lote))
                        for i in range(num_processos)]

            resultados = pool.starmap(encontrar_primos_em_lote, sublotes)

            primos = [primo for sublista in resultados for primo in sublista]
            f.write('\n'.join(map(str, primos)) + '\n')

    pool.close()
    pool.join()

def main():
    """
    Função principal para encontrar e salvar números primos dentro de um intervalo definido.
    """
    raizes = [2, 3, 5, 7]
    periodo = mpz(210)
    numero_ciclo = mpz(5_000)
    limite_inferior = mpz('1697804804198457671680')
    limite_superior = mpz('1697804804198458720256')
    arquivo_saida = 'primos.txt'
    tamanho_lote = mpz(1_000_000)
    num_processos = mp.cpu_count()

    Xi = calcular_diferencas_periodicas(raizes, periodo, numero_ciclo)
    L_b = construir_conjunto_multiplos(Xi, raizes, periodo, numero_ciclo, limite_inferior, limite_superior)

    encontrar_primos_em_paralelo(limite_inferior, limite_superior, tamanho_lote, arquivo_saida, num_processos)
    print(f"Primos encontrados no intervalo [{limite_inferior}, {limite_superior}] gravados em '{arquivo_saida}'.")

if __name__ == '__main__':
    main()
